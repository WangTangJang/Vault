依赖注入（Dependency Injection，简称DI）是一种设计模式，它用于实现对象之间的==解耦==。在依赖注入中，对象的==依赖关系==不是在内部创建或硬编码，而是通过外部注入依赖的方式实现。这样可以使得代码更加灵活、可维护、可测试，并且降低了组件之间的==耦合度==。
## 三种方式：
### 构造函数注入（Constructor Injection）： 
通过构造函数来注入依赖。当一个对象被创建时，其依赖关系通过构造函数的参数传递进来。
```java
public class MyClass {
    private MyDependency dependency;

    public MyClass(MyDependency dependency) {
        this.dependency = dependency;
    }
}
```
### Setter方法注入（Setter Injection）：
通过setter方法来注入依赖。对象的依赖通过setter方法进行设定。
```java
    public class MyClass {
        private MyDependency dependency;

        public void setDependency(MyDependency dependency) {
            this.dependency = dependency;
        }
    }
    ```

## 配置方式：
### 注解方式：
### XML配置方式：
#### Bean的作用域配置：
```xml
<bean id="myBean" class="com.example.MyBean" scope="prototype" />
```
这里的 `scope` 属性用于指定Bean的*作用域*，包括 `singleton`（默认值，单例）和 `prototype`（每次请求新实例）等。
#### 构造函数注入：
```xml
<bean id="myService" class="com.example.MyService"> 
	<constructor-arg ref="myDependency" />
</bean>
```
```java
class MyService {  
    private MyDependency dependency;  
  
    public MyService(MyDependency dependency) {  
        this.dependency = dependency;  
    }
}
```
#### 集合属性注入：
通过构造器的方式：
```xml
<bean id="myListBean" class="demo.MyCollectionBean">  
    <constructor-arg>  
        <list>  
            <value>1</value>  
            <value>2</value>  
            <value>3</value>  
            <value>3</value>  
        </list>  
    </constructor-arg>  
    <constructor-arg>  
        <map>  
            <entry key="1" value="one"/>  
            <entry key="2" value="two"/>  
            <entry key="3" value="three"/>  
        </map>  
    </constructor-arg>  
</bean>
```
```java
class MyCollectionBean{  
    private List<Integer> depList;  
    private Map<String,String> depMap;  
    public MyCollectionBean(List<Integer> depList,Map<String,String> depMap) {  
        this.depList = depList;  
        this.depMap = depMap;  
    }
}
```
通过set方法注入(XML中property里面的deplist就是Java代码里面的属性名）：
```xml
<bean id="myListBean" class="demo.MyCollectionBean">  
    <property name="depList">  
        <list>  
            <value>1</value>  
            <value>2</value>  
        </list>  
    </property>  
    <property name="depMap">  
        <map>  
            <entry key="1" value="one"/>  
            <entry key="2" value="two"/>  
        </map>  
    </property>  
</bean>
```
```java
class MyCollectionBean{  
    private List<Integer> depList;  
    private Map<String,String> depMap;  
  
    public void setDepList(List<Integer> depList) {  
        this.depList = depList;  
    }  
    public void setDepMap(Map<String, String> depMap) {  
        this.depMap = depMap;  
    }  
}
```
## 优势：
- **松耦合（Loose Coupling）：** 通过依赖注入，对象之间的关系变得更加灵活，不再硬编码在对象内部，降低了它们之间的耦合度。
- **可测试性（Testability）：** 由于依赖关系被外部注入，可以轻松地使用模拟对象（Mock Objects）来进行单元测试，而不需要依赖真实的实现。
- **可维护性（Maintainability）：** 对象的依赖关系在外部配置，使得系统更容易维护和修改。
- **可读性（Readability）：** 通过注入的方式，代码更加清晰，不再包含大量创建和管理依赖对象的代码。
