HashMap是Java中常用的一种[[哈希表]]实现，它存储键值对，并通过键来快速查找对应的值。HashMap 是无序的，即不会记录插入的顺序。
HashMap的实现原理主要涉及哈希函数、数组、链表（或[[红黑树]]）等概念。
## 基本实现原理：
### 哈希函数：
HashMap使用键的hashCode值来计算哈希码（hash code）。hashCode值是通过调用键对象的`hashCode()`方法得到的。哈希码的目的是将键均匀地分布到数组的不同位置。
### 数组：
HashMap内部维护一个数组，通常称为[[哈希表]]。数组的长度是HashMap的容量，一般是2的幂次方，例如16、32、64等。数组的每个位置称为桶（bucket）。
### 碰撞处理：
由于哈希函数的映射不一定是唯一的，不同的键可能计算得到相同的哈希码，这就是碰撞。HashMap使用链表或红黑树来处理碰撞：
   - **链表：** 如果多个键映射到同一个桶，它们会形成一个链表。这是最基本的碰撞处理方式。
   - **红黑树：** 当链表长度达到一定阈值时，链表会转换为红黑树，以提高查找效率。这个阈值在JDK8中是8。
### 键值对存储：
HashMap中的键值对存储在数组的桶中。每个桶包含一个链表（或红黑树），用于存储哈希码相同的键值对。
### 扩容：
当HashMap中的元素数量超过数组容量乘以加载因子时（默认加载因子为0.75），HashMap会进行扩容操作。扩容会重新计算每个键的哈希码，并将键值对重新分配到新的数组中。
### 迭代：
HashMap的迭代顺序并不是按照插入的顺序，而是按照数组桶的顺序。在JDK8中，当链表长度大于8时，会转换为红黑树，这会影响到迭代的顺序。
## 总结：
总体来说，HashMap通过使用哈希表的思想，结合链表和红黑树的数据结构，实现了高效的键值对存储和检索。在正常情况下，HashMap的查找、插入、删除等操作的时间复杂度是O(1)，但在最坏情况下可能变为O(n)，这取决于哈希碰撞的情况。