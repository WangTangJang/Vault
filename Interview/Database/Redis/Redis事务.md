在Redis中，事务是一组命令的集合，它们被作为一个单一、*原子性*的操作执行。Redis的事务不同于关系型数据库中的[[什么是事务？|传统事务]]，它是通过`MULTI`、`EXEC`、`DISCARD`和`WATCH`等命令实现的。
以下是Redis事务的关键概念和相关命令：
## MULTI命令：
- 事务开始的命令，用于标记一个事务的开始。执行`MULTI`后，后续的命令将被放入一个事务队列中，但不会立即执行。
 ```redis
 MULTI
 ```
## 事务队列：
   - 在执行`MULTI`之后，后续的命令将被放入一个事务队列中，而不是立即执行。这个队列中的命令只有在执行`EXEC`命令时才会被原子性地执行。
## EXEC命令：
   - 用于执行事务队列中的所有命令。如果事务执行成功，返回一个包含每个命令执行结果的数组。如果事务中的某个命令失败，整个事务会被回滚。
     ```redis
     EXEC
     ```
## DISCARD命令：
   - 用于取消事务，清空事务队列，放弃执行事务中的所有命令。
     ```redis
     DISCARD
     ```
## WATCH命令：
- 用于监视一个或多个键，如果在事务执行之前，这些键被其他客户端修改，事务将被取消。`WATCH`命令可以用于实现[[Mysql中的锁机制#乐观锁|乐观锁]]的机制。
 ```redis
 WATCH key [key ...]
 ```
## UNWATCH命令：
   - 用于取消对所有键的监视。执行`UNWATCH`后，客户端将不再受到键变化的影响。

     ```redis
     UNWATCH
     ```

Redis的事务机制虽然*不支持像关系型数据库那样的回滚、提交、隔离级别*等传统事务特性，但它提供了一种批量执行命令、保证原子性的机制。
^0c74c6

> [!quote] 摘录
> 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。
事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。


