控制反转（Inversion of Control，IoC）是一种设计原则，*它指的是将对象的创建、组装和管理的控制权从应用程序代码中反转到框架或容器中*。在传统的编程模型中，开发人员通常负责创建对象并管理它们之间的关系，而在IoC模型中，这种控制被反转了。

在IoC中，对象的创建和生命周期管理由*容器*负责，而不是由开发人员显式地创建和管理。IoC的核心思想是将应用程序的控制权交给容器，使得容器可以动态地注入依赖关系，而不是由开发人员硬编码这些关系。

IoC通常通过两种方式实现：
1. [[什么是依赖注入？|依赖注入]]（Dependency Injection，DI）;
2. **依赖查找（Dependency Lookup）：** 在依赖查找模型中，对象通过查找容器获取它所需要的依赖关系。这种方式相对较少使用，因为它会导致对象与容器的强耦合，降低了代码的可维护性。

Spring框架是一个典型的IoC**容器**，通过IoC，Spring容器负责管理应用程序中的对象，包括对象的创建、初始化、注入依赖关系以及销毁。开发人员只需要关注业务逻辑，而不需要过多地关心对象的创建和管理过程，从而使得代码更加模块化、可测试和可维护。
## 举例：
假设我们有一个汽车类（Car）和一个引擎类（Engine），汽车类依赖于引擎类，也就是说汽车类需要有一个引擎类的属性。
### 没有使用控制反转的例子
```java
class Car {
    private Engine engine; // 汽车类的属性

    public Car() {
        this.engine = new Engine(); // 在构造器中创建引擎类的实例
    }
}
```
**存在问题**：
- 首先，它使得汽车类和引擎类紧密耦合，如果我们想要换一个不同的引擎类，我们就必须修改汽车类的代码。
- 其次，它使得汽车类难以测试，因为我们无法用模拟对象（mock object）来替换引擎类的实例。最后，它使得汽车类不够灵活，因为我们无法在运行时**动态地**改变引擎类的实例。
### 使用控制反转的例子：
```java
class Car {
    private Engine engine; // 汽车类的属性

    public Car(Engine engine) {
        this.engine = engine; // 用构造器参数来传递引擎类的实例，这是一种依赖注入的方式
    }
}
```
在XML配置文件中，我们可以这样定义汽车类和引擎类的关系
```xml
<bean id="engine" class="Engine"/> // 定义一个引擎类的bean
<bean id="car" class="Car"> // 定义一个汽车类的bean
    <constructor-arg ref="engine"/> // 将引擎类的bean作为构造器参数注入到汽车类的bean中
</bean>
```
**好处**：
- 首先，它使得汽车类和引擎类松散耦合，如果我们想要换一个不同的引擎类，我们只需要修改XML配置文件，而不需要修改汽车类的代码。
- 其次，它使得汽车类容易测试，因为我们可以用模拟对象（mock object）来替换引擎类的实例，而不需要真正创建引擎类的实例。最后，它使得汽车类更加灵活，因为我们可以在运行时动态地改变引擎类的实例，而不需要重新编译汽车类的代码。